#!/bin/bash
set -euo pipefail

KONFLUX_CATALOG=quay.io/konflux-ci/tekton-catalog

# Use with a pipe to indent some text
indented() {
    awk '{print "  " $0}'
}

# Extract trusted task data from the acceptable bundles data bundle
trusted_task_data() {
    local acceptable_bundles_repo="$KONFLUX_CATALOG/data-acceptable-bundles"

    local blob_digest=$(oras manifest fetch "$acceptable_bundles_repo:latest" | jq -r '.layers[0].digest')

    oras blob fetch "$acceptable_bundles_repo@$blob_digest" --output -
}

# Find the digest and full image ref for a given task bundle
# Use the acceptable bundles data bundle
get_pinned_task_bundle_ref() {
    local task_name=$1
    local tag=$2

    local task_repo=$KONFLUX_CATALOG/task-$task_name
    local trusted_task_key="oci://$task_repo:$tag"

    # Assume the first one is is the newest and best
    local digest=$(trusted_task_data | yq ".trusted_tasks.\"$trusted_task_key\"[0].ref")

    if [[ $digest == "null" ]]; then
        echo "Can't find $trusted_task_key in the trusted task list. Aborting."
        exit 1
    fi

    # Include the tag as well as the digest
    echo "$task_repo:$tag@$digest"
}

# Prepare tekton bundles resolver data for injection into the pipeline task yaml
bundle_resolver_data() {
    local task_name=$1
    local version=$2

    local bundle_ref=$(get_pinned_task_bundle_ref $task_name $version)

    jq -c <<END_JSON
        {
            "params": [
                { "name": "name",   "value": "$task_name" },
                { "name": "bundle", "value": "$bundle_ref" },
                { "name": "kind",   "value": "task" }
            ],
            "resolver": "bundles"
        }
END_JSON
}

# Base URL for curl fetching
GIT_REF=main
BUILD_DEFS_URL=https://raw.githubusercontent.com/konflux-ci/build-definitions/refs/heads/${GIT_REF}

# Todo: Support finding tasks in all the non-docker pipelines.

# There are two simliar docker-build pipeline definitions, one conventional,
# and one that uses the oci trusted artifacts versions of the important tasks
PIPELINE_YAML=${BUILD_DEFS_URL}/pipelines/docker-build/docker-build.yaml
PIPELINE_YAML_OCI_TA=${BUILD_DEFS_URL}/pipelines/docker-build-oci-ta/docker-build-oci-ta.yaml

# The FBC pipeline has FBC specific tasks not found in the docker-build pipeline
PIPELINE_YAML_FBC=${BUILD_DEFS_URL}/pipelines/fbc-builder/fbc-builder.yaml

# Find the task in the pipeline definition from build-definitions repo
# and extract its yaml snippet
extract_pipeline_task_raw_yaml() {
    local task_name=$1

    # Detect an oci-ta or fbc task and choose the appropriate pipeline
    # (Beware there are probably edge cases where this isn't going to work.
    # Set pipeline_url manually here if you need to.)
    if [[ "${task_name}" =~ ^fbc-|-fbc$ ]]; then
        local pipeline_url=${PIPELINE_YAML_FBC}
    elif [[ "${task_name}" =~ -oci-ta ]]; then
        local pipeline_url=${PIPELINE_YAML_OCI_TA}
    else
        local pipeline_url=${PIPELINE_YAML}
    fi

    # Output the task's yaml, (as a list of length one for convenience)
    curl -s "${pipeline_url}" | yq ".spec.tasks[] | select(.taskRef.name == \"${task_name}\") | [.]"
}

# Show a list of tasks that we could get yaml snippets for.
# Include the task's version in the output.
list_known_tasks() {
    for p in $PIPELINE_YAML_OCI_TA $PIPELINE_YAML $PIPELINE_YAML_FBC; do
        curl -s "$p" | yq '.spec.tasks[].taskRef | (.name + " " + .version)' ;
    done | sort | uniq
}

# Put together a yaml snippet with a bundle resolved taskRef ready to insert
# into a Konflux pipeline
extract_pipeline_task() {
    local task_name=$1

    # Extract the raw yaml snippet
    local task_yaml=$(extract_pipeline_task_raw_yaml $task_name)

    if [[ "$task_yaml" == "[]" ]]; then
        echo "Task '$task_name' not found. Aborting. Known tasks:"
        list_known_tasks | indented
        exit 1
    fi

    # The version is something like 0.1 or 0.2. It should match the
    # tag in the tekton bundle image ref
    local task_version=$(yq '.[0].taskRef.version' <<< "$task_yaml")

    # Compact json for the new bundle resolved taskRef
    local bundle_task_ref=$(bundle_resolver_data $task_name $task_version)

    # Replace the standard in-cluster taskRef with a bundle resolved taskRef
    # and output the modified yaml
    yq ".[0] + {\"taskRef\": $bundle_task_ref } | [.]" <<< "$task_yaml"
}

# Expected to be either Pipeline or PipelineRun
get_pipeline_kind() {
    local pipeline_file="$1"

    yq '.kind' $pipeline_file
}

# Return a yq query that specifies where to find the tasks in the yaml pipeline file
get_pipeline_tasks_path() {
    local pipeline_file="$1"

    # So we can work with both a PipelineRun yaml file and a Pipeline yaml file
    case $(get_pipeline_kind $pipeline_file) in
        PipelineRun)
            echo ".spec.pipelineSpec.tasks"
            ;;
        Pipeline)
            echo ".spec.tasks"
            ;;
        *)
            echo "Unexpected kind found in $pipeline_file. Aborting."
            exit 1
            ;;
    esac
}

# Extract a named pipeline task from a pipeline definition
find_task_in_pipeline() {
    local pipeline_file="$1"
    local task_name="$2"

    local tasks_path=$(get_pipeline_tasks_path $pipeline_file)

    # Look in the list of tasks for tasks that have the matching name in the taskRef params and pick out the first one
    yq "[$tasks_path[] | select(.taskRef.params[] | select(.name == \"name\" and .value == \"$task_name\"))] | .[0]" < $pipeline_file
}

# Determine if a named pipeline task is present in a pipeline definition
detect_task_in_pipeline() {
    local pipeline_file="$1"
    local task_name="$2"

    local result=$(find_task_in_pipeline $pipeline_file $task_name)

    [[ "$result" != "null" ]]
}

# Determine if any oct-ta tasks are present in a pipeline definition
detect_oci_ta_pipeline() {
    local pipeline_file="$1"

    # The * will work as a wildcard in the yq query
    detect_task_in_pipeline $pipeline_file "*-oci-ta"
}

# Create the yaml snippet for a particular pipeline task and insert it into a pipeline
# definition right before a particular other task. Do a few sanity check beforehand.
insert_pipeline_task() {
    local pipeline_file="$1"
    local new_task_name="$2"
    local before_task_name="$3"

    if detect_task_in_pipeline $pipeline_file $new_task_name; then
        echo "Task '$new_task_name' found already in pipeline '$(basename $pipeline_file)'. Skipping."
        return
    fi

    if ! detect_task_in_pipeline $pipeline_file $before_task_name; then
        echo "Before task '$before_task_name' not found in pipeline '$(basename $pipeline_file)'. Skipping."
        return
    fi

    if ! detect_oci_ta_pipeline $pipeline_file; then
        if [[ ! $new_task_name =~ -oci-ta$ ]]; then
            echo "Adding an oci-ta task to a non-oci-ta pipeline is probably a mistake. Skipping."
            return
        fi
    else
        if [[ ! $new_task_name =~ -oci-ta$ ]]; then
            echo "Looks like your pipeline is oci-ta. Consider if there's an oci-ta version of this task you should use instead."
            # But continue, since it might be fine. Not all tasks in an oci-ta pipeline use the trusted artifacts.
        fi
    fi

    echo "Adding task $new_task_name to pipeline $pipeline_file"

    # The tasks have a name in the taskRef resolver and a name in the pipeline. Since
    # those can be different we now going to find the pipeline name of the "before task",
    # i.e. the task that we want to use to determine the place to insert the task.
    local before_task_pipeline_name=$(find_task_in_pipeline $pipeline_file $before_task_name | yq '.name')

    # Somewhere to stash the pipeline task yaml
    local task_yaml_tmp="/tmp/$new_task_name.yaml"

    # Prepare the yaml snippet to insert
    extract_pipeline_task "$new_task_name" > "$task_yaml_tmp"

    # Awk will look for this line so it knows where to insert the new task
    local before_line_match="- name: $before_task_pipeline_name"

    # Use awk instead of yq here to avoid producing unwanted formatting changes
    awk \
        -v new_task_file="$task_yaml_tmp" \
        -v before_line_match="$before_line_match" \
        '
            function get_indent(line) {
                match(line, /^[ ]*/)
                return substr(line, RSTART, RLENGTH)
            }

            {
                if ($0 ~ before_line_match && !added) {
                    indent = get_indent($0)
                    # Read lines from new task file
                    while ((getline line < new_task_file) > 0) {
                        # Apply correct indentation
                        print indent line
                    }
                    close(new_task_file)
                }
                print
            }
        ' \
        "$pipeline_file" > "$pipeline_file.tmp"

    # Update the original file with the modified content
    mv "$pipeline_file.tmp" "$pipeline_file"

    # Clean up the temporary file
    rm "$task_yaml_tmp"
}

# A wrapper for git diff
show_diff() {
    local pipeline_file="$1"
    local diff_opts="${2:-""}"
    local dir=$(dirname $pipeline_file)
    local file=$(basename $pipeline_file)

    (cd $dir && git diff $diff_opts $file )
}

# Replace commas with spaces to split a string into multiple values
# (Assume no spaces in the individual values)
comma_split_tasks() {
    local comma_separated_maybe="$1"

    echo "${comma_separated_maybe//,/ }"
}

# Return a list of the Konflux pipeline definitions in the .tekton directory
find_pipelines() {
    local git_repo_path="$1"

    # (Don't find non-standard 'kind: Pipeline' files, even though they can be patched)
    ( cd $git_repo_path && git grep -l 'kind: PipelineRun' .tekton/*.yaml )
}

# Just the usage part of the help
usage() {
    cat <<EOT
# Show a list of known pipeline tasks
${0} list-tasks

# Show the latest trusted bundle ref for given pipeline task
${0} task-ref <task-name> <version>

# Output a snippet of yaml suitable for adding a task to a Konflux pipeline
${0} task-yaml <task-name>

# Modify a Konflux pipeline definition to add a new task
# Supports multiple comma-separated task names
${0} patch <path-to-pipeline-yaml> <new-task-name>

# Modify all the Konflux pipelines in a git repo to add a new task
# Supports multiple comma-separated task names
${0} patch-all <path-to-git-repo> <new-task-name>

# Show this help
${0} help
EOT
}

# Show help for the command line options
show_help() {
    cat <<EOT
Konflux Pipeline Patcher

Usage:
$(usage | indented)

Source:
  https://github.com/simonbaird/konflux-pipeline-patcher
EOT
}

# Show usage information if the required number of args are
# not provided, instead of an error like `$3: unbound variable`
required_args() {
    local required_count=$1
    if [[ "$ARG_COUNT" < $required_count ]]; then
        echo "Usage:"
        usage | grep $MAIN_CMD | indented
        exit 1
    fi
}

MAIN_CMD="${1:-""}"
ARG_COUNT="$#"

# Main command handler
case "$MAIN_CMD" in
    "list-tasks")
        list_known_tasks
        ;;

    "task-ref")
        required_args 3
        TASK_NAME="$2"
        VERSION="$3"

        # Todo maybe: List all the versions if version is not specified
        get_pinned_task_bundle_ref "$TASK_NAME" "$VERSION"
        ;;

    "task-yaml")
        required_args 2
        TASK_NAME="$2"

        extract_pipeline_task "$TASK_NAME"
        ;;

    "patch")
        required_args 3
        PIPELINE_FILE="$2"
        NEW_TASK_NAME="$3"
        # The new task will be inserted before this task
        BEFORE_TASK_NAME="${4:-"deprecated-image-check"}"

        # Support multiple tasks separated by a comma
        for t in $(comma_split_tasks "$NEW_TASK_NAME"); do
            insert_pipeline_task $PIPELINE_FILE $t "$BEFORE_TASK_NAME"
        done
        show_diff $PIPELINE_FILE
        ;;

    "patch-all")
        required_args 3
        GIT_REPO_PATH="$2"
        NEW_TASK_NAME="$3"
        # The new task will be inserted before this task
        BEFORE_TASK_NAME="${4:-"deprecated-image-check"}"

        for p in $(find_pipelines $GIT_REPO_PATH); do
            # Support multiple tasks separated by a comma
            for t in $(comma_split_tasks "$NEW_TASK_NAME"); do
                insert_pipeline_task "$GIT_REPO_PATH/$p" $t "$BEFORE_TASK_NAME"
            done
        done
        show_diff "$GIT_REPO_PATH/.tekton" --stat
        ;;

    # For convenience since this can go directly into the readme
    "usage")
        usage
        ;;

    "help" | *)
        show_help
        ;;
esac

# vim: sw=4
